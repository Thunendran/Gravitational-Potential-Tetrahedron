# =============================================================================
# Example 03 Appendix A: Gravitational Acceleration Field in the Plane z = 1.1
# -----------------------------------------------------------------------------
# Description:
#     This example visualizes the gravitational acceleration vector field
#     generated by a single tetrahedron in a plane parallel to its base (z = 1.1).
#
#     It reproduces the equivalent Python reference implementation using
#     BigFloat precision and the analytical tetrahedral potential defined in
#     `GP_TetrahedronBigFloat_Optimized.jl`.
#
# Reference:
#     Periyandy, T., & Bevis, M. (2025).
#     "The Gravitational Potential Inside, On and Outside of a Homogeneous
#      Tetrahedron." (Appendix A)
#
# Authors:
#     Thunendran Periyandy (corresponding author)
#     Michael Bevis
#
# Date: November 2025
# =============================================================================

using LinearAlgebra
using StaticArrays
using PyPlot
using PyCall
using Printf

# --- Include the high-precision module ---
include("GP_TetrahedronBigFloat_Optimized.jl")
using .GP_TetrahedronBigFloat_Optimized

# --- Constants ---
setprecision(256)
const G = BigFloat(1.0)
const σ = BigFloat(1.0)
const h_grad = BigFloat(1e-10)

# -----------------------------------------------------------------------------
# Function: numerical gravitational acceleration by finite difference
# -----------------------------------------------------------------------------
function gravitational_acceleration_numerical(x::BigFloat, y::BigFloat, z::BigFloat,
                                              verts::Matrix{BigFloat})
    A, B, C, D = eachrow(verts)
    tet = GP_TetrahedronBigFloat_Optimized.TetrahedronBigFloat(
        SVector{3,BigFloat}(A),
        SVector{3,BigFloat}(B),
        SVector{3,BigFloat}(C),
        SVector{3,BigFloat}(D)
    )

    φ(P::SVector{3,BigFloat}) =
        GP_TetrahedronBigFloat_Optimized.compute_potential(tet, P; G=G, sigma=σ)

    f(x, y, z) = φ(SVector{3,BigFloat}(x, y, z))

    gx = (f(x + h_grad, y, z) - f(x - h_grad, y, z)) / (2 * h_grad)
    gy = (f(x, y + h_grad, z) - f(x, y - h_grad, z)) / (2 * h_grad)
    gz = (f(x, y, z + h_grad) - f(x, y, z - h_grad)) / (2 * h_grad)

    return gx, gy, gz
end

# -----------------------------------------------------------------------------
# Function: intersection of tetrahedron edges with a z = const plane
# -----------------------------------------------------------------------------
function intersection_polygon(verts::Matrix{BigFloat}; z_plane=BigFloat(0))
    edges = [(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)]
    points = SVector{3,BigFloat}[]

    for (i, j) in edges
        v1 = SVector{3,BigFloat}(verts[i, :])
        v2 = SVector{3,BigFloat}(verts[j, :])
        z1, z2 = v1[3], v2[3]

        if (z1 - z_plane) * (z2 - z_plane) < 0
            t = (z_plane - z1) / (z2 - z1)
            p = v1 .+ t .* (v2 .- v1)
            push!(points, p)
        end
    end

    return points
end

# -----------------------------------------------------------------------------
# --- Define tetrahedron vertices ---
# -----------------------------------------------------------------------------
vertices = BigFloat.([
    [1.2  1.2  1.0];
    [2.0  1.0  1.0];
    [1.0  2.0  1.0];
    [1.5  1.5  2.0]
])

# -----------------------------------------------------------------------------
# --- Grid in z = 1.1 plane ---
# -----------------------------------------------------------------------------
z_fixed = BigFloat(1.1)
x_vals = BigFloat.(range(0.75, 2.25, length=13))
y_vals = BigFloat.(range(0.75, 2.25, length=13))

X = [x for y in y_vals, x in x_vals]
Y = [y for y in y_vals, x in x_vals]
U = zeros(Float64, size(X))
V = zeros(Float64, size(Y))

# -----------------------------------------------------------------------------
# Compute acceleration field
# -----------------------------------------------------------------------------
println("Computing gravitational acceleration field on z = 1.1 plane...")
for i in eachindex(X)
    gx, gy, gz = gravitational_acceleration_numerical(X[i], Y[i], z_fixed, vertices)
    U[i] = Float64(gx)
    V[i] = Float64(gy)
end

# -----------------------------------------------------------------------------
# Intersection polygon with z = 1.1 plane
# -----------------------------------------------------------------------------
intersection_points = intersection_polygon(vertices; z_plane=z_fixed)

# -----------------------------------------------------------------------------
# Plotting
# -----------------------------------------------------------------------------
fig, ax = subplots(figsize=(8, 7))
ax.quiver(Float64.(X), Float64.(Y), U, V,
          color="red", scale=10, pivot="middle", width=0.003)

# Add intersection polygon
if length(intersection_points) ≥ 3
    xcoords = [Float64(p[1]) for p in intersection_points]
    ycoords = [Float64(p[2]) for p in intersection_points]
    ax.plot(vcat(xcoords, xcoords[1]), vcat(ycoords, ycoords[1]),
            color="black", linewidth=1, label="Tetrahedral Boundary")
end

# -----------------------------------------------------------------------------
# Legend and formatting
# -----------------------------------------------------------------------------
legend = ax.legend(loc="lower right", frameon=false)
for text_obj in legend.get_texts()
    text_obj.set_color("black")
    text_obj.set_fontsize(14)
end

ax.set_title("Gravitational Acceleration Field in the Plane z = 1.1",
             fontsize=17, color="black")
ax.set_xlabel("x", fontsize=16, color="black")
ax.set_ylabel("y", fontsize=16, color="black")
ax.tick_params(axis="both", colors="black")
ax.set_xlim([0.7, 2.3])
ax.set_ylim([0.7, 2.3])
ax.set_aspect("equal")
ax.grid(false)

savefig("gravitational_acceleration_field_z1_1_julia.png",
        dpi=300, bbox_inches="tight")
show()

println("✅ Figure saved as gravitational_acceleration_field_z1_1_julia.png")
