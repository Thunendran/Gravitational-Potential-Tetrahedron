# =============================================================================
#  Module: G_TetrahedronPotential_Optimized
# -----------------------------------------------------------------------------
#  Description:
#      Singularity-free analytical computation of the gravitational potential
#      generated by a homogeneous tetrahedron using double-precision (Float64)
#      arithmetic. This implementation provides a highly efficient formulation
#      with geometric quantities precomputed upon initialization.
#
#      The module defines:
#          • TetrahedronPotential  –  stores vertices, geometry, and constants.
#          • compute_potential      –  evaluates potential at a single point.
#          • compute_potentials     –  computes potentials for multiple points
#                                      using multithreading for speed.
#
#      All equations follow the analytical expressions derived in
#      Periyandy & Bevis (2025), ensuring numerical stability across the
#      interior, boundary, and exterior regions of the tetrahedron.
#
#  Numerical Scope:
#      This version operates with standard machine precision (Float64),
#      suitable for general simulations, field visualization, and
#      performance-sensitive applications.
#
#  Reference:
#      Periyandy, T., & Bevis, M. (2025).
#      "The Gravitational Potential Inside, On and Outside of a Homogeneous Tetrahedron."
#
#      Supplementary Material:
#      Julia Implementation — Machine-Precision Optimized Version
#
#  Authors:
#      Thunendran Periyandy  (corresponding author)
#          Division of Geodetic Science, School of Earth Sciences,
#          The Ohio State University, USA
#          Faculty of Geomatics, Sabaragamuwa University of Sri Lanka
#          Email: thunendran@gmail.com
#
#      Michael Bevis
#          Division of Geodetic Science, School of Earth Sciences,
#          The Ohio State University, USA
#          Email: mbevis@gmail.com
#
#  Version: 1.0
#  Date:    November 2025
# =============================================================================

module G_TetrahedronPotential_Optimized

using LinearAlgebra, StaticArrays, SpecialFunctions, Base.Threads

export TetrahedronPotential, compute_potential, compute_potentials

# ==========================================================
# Type Definition
# ==========================================================
struct TetrahedronPotential{T}
    verts::NTuple{4,SVector{3,T}}       # A,B,C,D vertices
    G::T                                # Gravitational constant
    sigma::T                                # Density
    centroid::SVector{3,T}              # Precomputed centroid
    edge_len::Matrix{T}                 # 4×4 edge lengths
    edge_vec::Matrix{SVector{3,T}}      # 4×4 edge vectors
    faces::NTuple{4,NTuple{3,Int}}      # Face vertex indices
end

# ==========================================================
# Constructor (precomputes geometry once)
# ==========================================================
function TetrahedronPotential(A::AbstractVector{T},
                              B::AbstractVector{T},
                              C::AbstractVector{T},
                              D::AbstractVector{T};
                              G::T=one(T),
                              sigma::T=one(T)) where {T<:Real}

    A_a, B_a, C_a, D_a = SVector{3,T}(A), SVector{3,T}(B),
                     SVector{3,T}(C), SVector{3,T}(D)
    V = dot(cross(B_a - A_a, C_a - A_a), D_a - A_a)
    if V < 0
        B_a, C_a = C_a, B_a
    end

    verts = (A_a, B_a, C_a, D_a)
    centroid = (A_a + B_a + C_a + D_a) / 4

    edge_len = Matrix{T}(undef, 4, 4)
    edge_vec = Matrix{SVector{3,T}}(undef, 4, 4)
    for i in 1:4, j in 1:4
        v_i, v_j = verts[i], verts[j]
        edge_vec[i,j] = v_j - v_i
        edge_len[i,j] = norm(edge_vec[i,j])
    end

    faces = ((1,3,2), (1,2,4), (2,3,4), (3,1,4))
    return TetrahedronPotential{T}(verts, G, sigma, centroid, edge_len, edge_vec, faces)
end

# ==========================================================
# Inline math utilities
# ==========================================================
@inline special_log_term(ra, rb, rab) =
    (rab > 0 && ra + rb > rab) ? log((ra + rb + rab) / (ra + rb - rab)) / rab : zero(ra)

@inline special_atan_term(rval, detA, detB, dotv, diffz, num) =
    rval > 0 ? atan(num, -((detA * detB) + diffz^2 * dotv) / rval) : zero(rval)

# ==========================================================
# Potential at a single point ( Calculations )
# ==========================================================
function compute_potential(tet::TetrahedronPotential{T}, P::SVector{3,T}) where {T}
    verts = tet.verts
    G, sigma, centroid = tet.G, tet.sigma, tet.centroid
    edge_len, edge_vec, faces = tet.edge_len, tet.edge_vec, tet.faces

    # Vertex distances
    vertex_r = SVector{4,T}(map(v -> norm(v - P), verts))

    # Cross products S_ij
    S = Matrix{SVector{3,T}}(undef, 4, 4)
    for i in 1:4, j in 1:4
        S[i,j] = cross(verts[i] - P, verts[j] - P)
    end

    totalU = zero(T)
    @inbounds for (n1, n2, n3) in faces
        v1, v2, v3 = verts[n1], verts[n2], verts[n3]
        nraw = cross(v2 - v1, v3 - v1)
        if dot(nraw, (v1 + v2 + v3)/3 - centroid) < 0
            nraw = -nraw
        end
        normn = norm(nraw)
        nunit = normn > 0 ? nraw / normn : SVector{3,T}(0,0,0)
        diffz = dot(v1 - P, nunit)
        num = diffz * normn

        det12 = dot(S[n1,n2], nunit)
        det23 = dot(S[n2,n3], nunit)
        det31 = dot(S[n3,n1], nunit)
        r1, r2, r3 = vertex_r[n1], vertex_r[n2], vertex_r[n3]
        e12, e23, e31 = edge_len[n1,n2], edge_len[n2,n3], edge_len[n3,n1]

        L12 = special_log_term(r1, r2, e12)
        L23 = special_log_term(r2, r3, e23)
        L31 = special_log_term(r3, r1, e31)
        term1 = diffz * (det12 * L12 + det23 * L23 + det31 * L31)

        dot1 = dot(edge_vec[n1,n2], edge_vec[n3,n1])
        dot2 = dot(edge_vec[n2,n3], edge_vec[n1,n2])
        dot3 = dot(edge_vec[n3,n1], edge_vec[n2,n3])
        S1 = special_atan_term(r1, det31, det12, dot1, diffz, num)
        S2 = special_atan_term(r2, det12, det23, dot2, diffz, num)
        S3 = special_atan_term(r3, det23, det31, dot3, diffz, num)
        term2 = (diffz^2) * (S1 + S2 + S3 - sign(diffz) * π)

        totalU += 0.5 * (term1 - term2)
    end

    return G * sigma * totalU
end

# ==========================================================
# Vectorized potential (multi-threaded)
# ==========================================================
function compute_potentials(tet::TetrahedronPotential{T}, points::Matrix{T}) where {T}
    N = size(points, 1)
    U = Vector{T}(undef, N)
    @threads for i in 1:N
        P = SVector{3,T}(points[i,1], points[i,2], points[i,3])
        U[i] = compute_potential(tet, P)
    end
    return U
end

end # module
