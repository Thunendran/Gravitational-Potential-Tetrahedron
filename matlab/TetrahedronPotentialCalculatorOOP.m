classdef TetrahedronPotentialCalculatorOOP
    % =========================================================================
    % Class: TetrahedronPotentialCalculatorOOP
    % -------------------------------------------------------------------------
    % Description:
    %     Computes the gravitational potential at one or more field points
    %     generated by a homogeneous tetrahedron of uniform surface density
    %     using an *analytical face-based formulation*.
    %
    %     This implementation adopts a modular, object-oriented architecture
    %     that:
    %         - Encapsulates all tetrahedral geometric and physical parameters.
    %         - Provides both single-point and vectorized (parallel) evaluation.
    %         - Ensures correct orientation and sign convention of faces.
    %         - Supports analytical validation (inside, on, or outside tetrahedron).
    %
    % Reference:
    %     Periyandy, T., & Bevis, M. (2025).
    %     "The Gravitational Potential Inside, On and Outside of a
    %      Homogeneous Tetrahedron."
    %
    % Authors:
    %     Thunendran Periyandy  (corresponding author)
    %         Division of Geodetic Science, School of Earth Sciences,
    %         The Ohio State University, USA
    %         Faculty of Geomatics, Sabaragamuwa University of Sri Lanka
    %
    %     Michael Bevis
    %         Division of Geodetic Science, School of Earth Sciences,
    %         The Ohio State University, USA
    %
    % Version: 1.0
    % Date:    July 31, 2025
    % =========================================================================
    
    properties
        % Vertices of the tetrahedron (1×3 vectors)
        A
        B
        C
        D
        
        % Optional evaluation point
        P
        
        % Physical constants
        G = 1        % Gravitational constant (normalized)
        sigma = 1    % Surface mass density
        eps = 0      % Numerical tolerance (for degenerate checks)
    end
    
    % ======================================================================
    % Constructor
    % ======================================================================
    methods
        function obj = TetrahedronPotentialCalculatorOOP(A,B,C,D,P,G,sigma,eps)
            % -----------------------------------------------------------------
            % Constructor: Initializes tetrahedron geometry and constants.
            %
            % Usage:
            %   obj = TetrahedronPotentialCalculatorOOP(A,B,C,D)
            %   obj = TetrahedronPotentialCalculatorOOP(A,B,C,D,P)
            %   obj = TetrahedronPotentialCalculatorOOP(A,B,C,D,P,G,sigma,eps)
            %
            % Inputs:
            %   A,B,C,D : 1×3 vertex coordinates of tetrahedron
            %   P       : (optional) evaluation point
            %   G       : (optional) gravitational constant
            %   sigma   : (optional) surface mass density
            %   eps     : (optional) tolerance threshold
            %
            % Output:
            %   obj     : constructed object instance
            % -----------------------------------------------------------------
            
            if nargin > 0
                [obj.A,obj.B,obj.C,obj.D] = obj.preserve_orientation_tetrahedron(A,B,C,D);
                if nargin >= 5, obj.P = P; end
                if nargin >= 6, obj.G = G; end
                if nargin >= 7, obj.sigma = sigma; end
                if nargin >= 8, obj.eps = eps; end
            end
        end
        
    % ======================================================================
    % Main Computational Methods
    % ======================================================================
        function U = compute(obj,P)
            % -----------------------------------------------------------------
            % compute
            %
            % Computes the gravitational potential at a single field point.
            %
            % Usage:
            %   U = obj.compute(P)
            %   U = obj.compute()   % Uses P defined in constructor
            %
            % Inputs:
            %   P : 1×3 vector — point of evaluation
            %
            % Output:
            %   U : scalar — gravitational potential value
            %
            % Notes:
            %   Implements the closed-form solution using logarithmic and
            %   arctangent face integrals as described in Periyandy & Bevis (2025).
            % -----------------------------------------------------------------
            
            if nargin < 2
                P = obj.P;
            end
            face_data = obj.precompute_geometric_data_vectorized(P);
            total_U = 0.0;
            
            % Summation over the four tetrahedral faces
            names = fieldnames(face_data);
            for k = 1:numel(names)
                data = face_data.(names{k});
                
                [L12,L23,L31] = obj.compute_log_terms(data.r, data.edges);
                [S1,S2,S3]   = obj.compute_arctangent_terms( ...
                    data.determinants, data.r, data.diff_z, data.numerator, data.dots);
                
                dets = data.determinants;
                diff_z = data.diff_z;
                
                % Face contribution
                term1 = diff_z * (dets(1)*L12 + dets(2)*L23 + dets(3)*L31);
                term2 = (diff_z^2) * (S1 + S2 + S3 - sign(diff_z)*pi);
                total_U = total_U + 0.5*(term1 - term2);
            end
            U = -obj.G * obj.sigma * total_U;
        end
        
        function potentials = compute_vectorized(obj, points)
            % -----------------------------------------------------------------
            % compute_vectorized
            %
            % Parallelized computation of potentials at multiple field points.
            %
            % Usage:
            %   potentials = obj.compute_vectorized(points)
            %
            % Inputs:
            %   points : N×3 matrix of coordinates
            %
            % Output:
            %   potentials : N×1 vector of gravitational potentials
            %
            % Notes:
            %   Automatically initializes a MATLAB parallel pool (parpool)
            %   if one does not exist, ensuring multi-core computation.
            % -----------------------------------------------------------------
            
            N = size(points,1);
            potentials = zeros(N,1);
        
            pool = gcp('nocreate');
            if isempty(pool)
                parpool;
            end
        
            parfor i = 1:N
                potentials(i) = obj.compute(points(i,:));
            end
        end
    end
    
    % ======================================================================
    % Private Helper Methods
    % ======================================================================
    methods (Access = private)
        function [A,B,C,D] = preserve_orientation_tetrahedron(~,A,B,C,D)
            % -----------------------------------------------------------------
            % preserve_orientation_tetrahedron
            %
            % Ensures the vertex ordering produces a positive signed volume.
            %
            % Output:
            %   Possibly reordered vertices (A,B,C,D)
            % -----------------------------------------------------------------
            
            V = dot(cross(B - A, C - A), D - A);
            if V < 0
                tmp = B; B = C; C = tmp;
            end
        end
        
        function flag = fast_face_plane_check(obj,P,A,B,C)
            % -----------------------------------------------------------------
            % fast_face_plane_check
            %
            % Determines if point P lies exactly on face ABC within tolerance.
            %
            % Output:
            %   flag : logical — true if point is coplanar with the face.
            % -----------------------------------------------------------------
            
            n = cross(B - A, C - A);
            norm_n = norm(n);
            if norm_n == obj.eps
                flag = false;
                return;
            end
            n_unit = n / norm_n;
            signed_dist = dot(n_unit, P - A);
            flag = abs(signed_dist) == obj.eps;
        end
        
        function face_data = precompute_geometric_data_vectorized(obj,P)
            % -----------------------------------------------------------------
            % precompute_geometric_data_vectorized
            %
            % Precomputes all face-related geometric quantities required for
            % the analytical potential expression, including:
            %     - Edge vectors and lengths
            %     - Cross products between vertex-position vectors
            %     - Face normals and signed distances
            %     - Determinants, dot products, and radii
            %
            % Output:
            %   face_data : struct containing parameters for each tetrahedral face.
            % -----------------------------------------------------------------
            
            A = obj.A; B = obj.B; C = obj.C; D = obj.D;
            faces_def = { {'ACB',A,C,B}, {'ABD',A,B,D}, ...
                          {'BCD',B,C,D}, {'CAD',C,A,D} };
            tetra_centroid = (A+B+C+D)/4.0;
            
            % Map vertices for vectorized lookup
            vertices_map = struct('A',A,'B',B,'C',C,'D',D);
            vertex_r.A = norm(A - P);
            vertex_r.B = norm(B - P);
            vertex_r.C = norm(C - P);
            vertex_r.D = norm(D - P);
            
            % Edge lengths and vectors
            edges_list = {'AB','AC','AD','BC','BD','CD'};
            edge_lengths = struct();
            edge_vectors = struct();
            for i = 1:length(edges_list)
                key = edges_list{i};
                v1 = vertices_map.(key(1));
                v2 = vertices_map.(key(2));
                L = norm(v2 - v1);
                edge_lengths.(key) = L;
                edge_lengths.(fliplr(key)) = L;
                edge_vectors.(key) = v2 - v1;
                edge_vectors.(fliplr(key)) = v1 - v2;
            end
            
            % Cross products S_ij = (v_i - P) × (v_j - P)
            names_v = fieldnames(vertices_map);
            S = struct();
            for i = 1:length(names_v)
                for j = i+1:length(names_v)
                    vi = vertices_map.(names_v{i});
                    vj = vertices_map.(names_v{j});
                    key = [names_v{i} names_v{j}];
                    S.(key) = cross(vi - P, vj - P);
                    S.(fliplr(key)) = -S.(key);
                end
            end
            
            % Assemble data for each face
            face_data = struct();
            for f = 1:length(faces_def)
                name = faces_def{f}{1};
                v1 = faces_def{f}{2};
                v2 = faces_def{f}{3};
                v3 = faces_def{f}{4};
                
                if obj.fast_face_plane_check(P,v1,v2,v3)
                    continue;
                end
                
                n_raw = cross(v2 - v1, v3 - v1);
                if dot(n_raw, (v1+v2+v3)/3.0 - tetra_centroid) < 0
                    n_raw = -n_raw;
                end
                norm_val = norm(n_raw);
                if norm_val > 0
                    n_unit = n_raw / norm_val;
                else
                    n_unit = zeros(1,3);
                end
                
                % Face edge definitions and determinant computations
                v_names = {faces_def{f}{2}, faces_def{f}{3}, faces_def{f}{4}};
                keys_v = {'A','B','C','D'};
                idxs = cell(1,3);
                for kk = 1:3
                    for kv = 1:4
                        if all(vertices_map.(keys_v{kv}) == v_names{kk})
                            idxs{kk} = keys_v{kv};
                        end
                    end
                end
                
                e1_key = [idxs{1} idxs{2}];
                e2_key = [idxs{2} idxs{3}];
                e3_key = [idxs{3} idxs{1}];
                
                dets = [ dot(S.(e1_key),n_unit), ...
                         dot(S.(e2_key),n_unit), ...
                         dot(S.(e3_key),n_unit) ];
                r_vals = [ vertex_r.(idxs{1}), vertex_r.(idxs{2}), vertex_r.(idxs{3}) ];
                edges_vals = [ edge_lengths.(e1_key), edge_lengths.(e2_key), edge_lengths.(e3_key) ];
                
                dot1 = dot(edge_vectors.(e1_key), edge_vectors.([idxs{3} idxs{1}]));
                dot2 = dot(edge_vectors.(e2_key), edge_vectors.([idxs{1} idxs{2}]));
                dot3 = dot(edge_vectors.(e3_key), edge_vectors.([idxs{2} idxs{3}]));
                
                diff_z = dot(v1 - P, n_unit);
                numerator = diff_z * norm_val;
                
                % Store data per face
                face_data.(name).r = r_vals;
                face_data.(name).edges = edges_vals;
                face_data.(name).determinants = dets;
                face_data.(name).diff_z = diff_z;
                face_data.(name).numerator = numerator;
                face_data.(name).dots = [dot1,dot2,dot3];
            end
        end
        
        function [L12,L23,L31] = compute_log_terms(~, r, edges)
            % -----------------------------------------------------------------
            % compute_log_terms
            %
            % Computes the three logarithmic terms of the analytical potential
            % formula for one triangular face:
            %       Lij = log( (ri + rj + rij) / (ri + rj - rij) ) / rij
            %
            % Inputs:
            %   r     : [r1, r2, r3] distances from P to vertices
            %   edges : [L12, L23, L31] edge lengths
            % -----------------------------------------------------------------
            
            r1 = r(1); r2 = r(2); r3 = r(3);
            r12 = edges(1); r23 = edges(2); r31 = edges(3);
            
            function val = log_term(ra,rb,rab)
                if rab < 0
                    val = 0.0; return;
                end
                num = ra + rb + rab;
                den = ra + rb - rab;
                if den <= 0
                    val = 0.0;
                else
                    val = log(num/den) / rab;
                end
            end
            
            L12 = log_term(r1,r2,r12);
            L23 = log_term(r2,r3,r23);
            L31 = log_term(r3,r1,r31);
        end
        
        function [S1,S2,S3] = compute_arctangent_terms(obj,dets,r,diff_z,numerator,dots)
            % -----------------------------------------------------------------
            % compute_arctangent_terms
            %
            % Computes the arctangent terms associated with the face angles:
            %       Si = atan2( numerator, denominator_i )
            %
            % Inputs:
            %   dets     : determinant terms per edge
            %   r        : vertex distances
            %   diff_z   : signed distance to face
            %   numerator: intermediate geometric factor
            %   dots     : dot products between edge vectors
            %
            % -----------------------------------------------------------------
            
            eps_val = obj.eps;
            if r(1) > eps_val
                denom_1 = -((dets(3)*dets(1)) + diff_z^2 * dots(1)) / r(1);
                S1 = atan2(numerator, denom_1);
            else
                S1 = 0.0;
            end
            if r(2) > eps_val
                denom_2 = -((dets(1)*dets(2)) + diff_z^2 * dots(2)) / r(2);
                S2 = atan2(numerator, denom_2);
            else
                S2 = 0.0;
            end
            if r(3) > eps_val
                denom_3 = -((dets(2)*dets(3)) + diff_z^2 * dots(3)) / r(3);
                S3 = atan2(numerator, denom_3);
            else
                S3 = 0.0;
            end
        end
    end
end
